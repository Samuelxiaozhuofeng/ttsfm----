# 模块结构设计：AI 模块拆分方案

本说明文档用于记录当前项目中 **AI 相关功能** 从 [`app.py`](app.py:1) 中拆分为独立模块的设计方案与结构约定。

---

## 一、拆分目标

原本在 [`app.py`](app.py:335) 之后的 AI 相关逻辑（AI 设置、AI 连通性测试、章节问答聊天、聊天记录管理）集中在主 Flask 应用文件中，职责较多。

拆分目标：

1. 将 **AI 相关路由与业务逻辑** 抽离到独立模块，降低 `app.py` 复杂度。
2. 保持对外接口 URL 不变（例如 `/api/ai/settings`、`/api/chat/message` 等）。
3. 让 AI 模块具备清晰的边界，便于后续扩展（例如支持多模型、多服务商）。

---

## 二、拆分方式选择

### 方案 A：`ai_routes.py`（推荐）

- 形式：**Flask Blueprint + 轻量服务函数**
- 职责：
  - 在 `ai_routes.py` 中定义一个 `Blueprint`，注册所有 AI 相关路由。
  - 将与 HTTP 强相关的逻辑（请求解析、响应格式）放在 Blueprint 中。
  - 复杂的调用逻辑可以进一步抽到 `ai_service.py`（可选）。

**优点：**

- 与现有 Flask 结构最自然的集成方式。
- `app.py` 中只需要 `app.register_blueprint(ai_bp)`，主文件更简洁。
- 未来可以很容易把 AI 模块挂载到不同前缀（如 `/ai`）或不同应用。

### 方案 B：`ai_service.py`（服务类 / 函数）

- 形式：**纯业务服务模块**，不直接定义路由。
- 职责：
  - 提供纯 Python 函数，如：
    - `load_ai_settings(library: Library) -> dict`
    - `save_ai_settings(library: Library, ...)`
    - `test_ai_connection(api_url, api_key, model) -> dict`
    - `chat_with_ai(library: Library, chapter_id, user_message) -> str`
  - `app.py` 或 `ai_routes.py` 只负责 HTTP 层，调用这些服务函数。

**优点：**

- 业务逻辑与 Web 框架解耦，便于单元测试。
- 将来如果换成 FastAPI / CLI / 其他入口，只需复用 service 层。

---

## 三、推荐最终结构

综合考虑当前项目规模与可维护性，推荐采用：

- `ai_routes.py`：**必须有**，承载 Blueprint 和路由。
- `ai_service.py`：**可选**，当 AI 逻辑继续变复杂时再抽取。

### 1. 文件结构（目标）

```text
.
├── app.py                 # 主 Flask 应用入口，只保留通用路由和模块注册
├── ai_routes.py           # AI 相关 Blueprint（路由定义）
├── ai_service.py          # （可选）AI 业务逻辑封装
├── library.py             # Library 数据管理（章节 / 进度 / AI 设置 / 聊天记录）
├── library_data.json
├── read_text.py
├── text.md
├── 模块结构.md
├── templates/
│   ├── index.html
│   ├── library.html
│   └── reader.html
├── uploads/
└── outputs/
```

---

## 四、`ai_routes.py` 设计

### 1. Blueprint 定义

- 模块：`ai_routes.py`
- Blueprint 名称：`ai_bp`
- URL 前缀：`/api`（可选，若保持现有路径不变，也可以不加前缀）

示例结构（伪代码）：

```python
# ai_routes.py

from flask import Blueprint, request, jsonify
from library import Library
import requests
import time

from .ai_service import (
    build_chat_endpoint,
    test_ai_connectivity,
    build_chat_messages,
)

ai_bp = Blueprint('ai', __name__)

# 依赖注入：在 create_app 或 app.py 中把 Library 实例传进来
library: Library = None

def init_ai_routes(app, library_instance: Library):
    global library
    library = library_instance
    app.register_blueprint(ai_bp)
```

> 说明：  
> - 这里使用 `init_ai_routes(app, library_instance)` 的方式，把 `Library` 实例注入到 `ai_routes` 中，避免循环导入。
> - 也可以使用 `current_app.config['LIBRARY']` 的方式存放依赖。

### 2. 路由映射

从原 [`app.py`](app.py:335) 中迁移的路由：

1. `GET /api/ai/settings` → `get_ai_settings()`
2. `POST /api/ai/settings` → `save_ai_settings()`
3. `POST /api/ai/test` → `test_ai_connection()`
4. `GET /api/chat/history/<chapter_id>` → `get_chat_history()`
5. `DELETE /api/chat/history/<chapter_id>` → `clear_chat_history()`
6. `POST /api/chat/message` → `chat_message()`

迁移后，这些函数将定义在 `ai_routes.py` 中，并通过 `ai_bp.route(...)` 注册。

---

## 五、`ai_service.py` 设计（可选）

如果你希望进一步解耦业务逻辑，可以把下列函数从 `ai_routes.py` 中抽到 `ai_service.py`：

1. **端点规范化**

   - 原函数：[`build_chat_endpoint(base_url: str) -> str`](app.py:40)
   - 迁移到 `ai_service.py`，供测试接口和聊天接口复用。

2. **AI 连通性测试**

   - 新函数示例：
     ```python
     def test_ai_connectivity(api_url: str, api_key: str, model: str) -> dict:
         """
         调用 OpenAI 兼容接口，返回：
         {
             "ok": bool,
             "duration_ms": int,
             "response_preview": str,
             "error": Optional[str]
         }
         """
     ```

3. **聊天消息构造**

   - 新函数示例：
     ```python
     def build_chat_messages(chapter_content: str, history: list, user_message: str) -> list:
         """
         根据章节内容、历史对话和当前问题，构造 messages 列表。
         """
     ```

4. **发送聊天请求**

   - 新函数示例：
     ```python
     def call_chat_api(endpoint: str, api_key: str, model: str, messages: list, temperature: float = 0.7) -> str:
         """
         调用 /chat/completions，返回 assistant 的回复文本。
         """
     ```

`ai_routes.py` 中的路由函数只负责：

- 从 `request` 中取参数
- 调用 `ai_service` 的函数
- 处理异常并返回 JSON

---

## 六、`app.py` 中的改动点（概念层面）

在完成拆分后，`app.py` 中与 AI 相关的内容将：

1. **删除或迁移：**

   - 删除原有的：
     - `build_chat_endpoint()`
     - `/api/ai/settings` 路由
     - `/api/ai/test` 路由
     - `/api/chat/history/*` 路由
     - `/api/chat/message` 路由

2. **新增：**

   - 导入并初始化 AI 模块：
     ```python
     from ai_routes import init_ai_routes

     # 初始化 Library
     library = Library()

     # 初始化 AI 路由（在创建 app 后）
     init_ai_routes(app, library)
     ```

3. **保持不变：**

   - 其他与 TTS、章节管理、文件上传等相关的路由保持在 `app.py` 中。

---

## 七、对前端的影响

拆分为 `ai_routes.py` / `ai_service.py` 后：

- **前端 URL 不变**：
  - `index.html` 中：
    - `/api/ai/settings`
    - `/api/ai/test`
  - `reader.html` 中：
    - `/api/chat/history/<chapter_id>`
    - `/api/chat/message`
- 因此 **前端代码无需修改**，只要后端在新模块中注册了相同路径的路由即可。

---

## 八、后续扩展建议

1. **多 AI 提供商支持**
   - 在 `ai_service.py` 中增加“提供商”抽象，例如：
     - `provider: "openai" | "azure" | "local" ...`
   - 根据配置选择不同的调用方式。

2. **错误日志与监控**
   - 在 `ai_service.py` 中统一捕获 `requests` 异常，记录日志（如超时、认证失败等）。

3. **单元测试**
   - 对 `ai_service.py` 中的纯函数编写单元测试，不依赖 Flask 环境。

---

以上为当前项目中 AI 模块从 `app.py` 拆分为 `ai_routes` / `ai_service` 的结构设计说明。实际代码迁移时，可按本文件的结构逐步实现。